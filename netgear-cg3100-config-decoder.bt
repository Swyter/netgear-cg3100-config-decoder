//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: Netgear GC3100 *decoded* config backup
//   Authors: Swyter
//   Version: 2022.02.05
//   Purpose: Open descrambled GatewaySettings.bin files.
//  Category: Network
//  ID Bytes: [+16] 36 75 39 65 [+46] 01 02
// File Mask: GatewaySettings*.bin*
//------------------------------------------------

BigEndian();

typedef struct
{
    byte tag_len;
    if (tag_len)
        char s[tag_len];
} rgltag <read=read_rgltag, optimize=false>;

string read_rgltag(struct rgltag& _thing)
{
    if (_thing.tag_len <= 0) return "<empty>"; else return _thing.s;
}

typedef struct
{
    local int saved_offset = FTell();

    ushort block_size <format=hex>;
    char tag[4]; ubyte ver_a, ver_b;

    if      (Strcmp(tag, "8021") == 0) /* 8021 [0.29] */
    {
        char wifi_ssid[33];
        char settings_block[91];
        char crap[0xef];
        rgltag passwd;
        char more_crap[0xa7];
        rgltag tags[4];
        char aa[3];
        rgltag tagsb[5];
        char aaa;
        rgltag tagsc[1];
        char crapb[7-3];
        uint crup[4];
        uint repeated[4];
    }
    else if (Strcmp(tag, "WiGu") == 0) /* WiGu [0.10] */
    {
        struct elem
        {
            byte zero;
            ubyte num;
            byte zero;
            char wifi_ssid[33];
            char buf[76];
            char pad[40];
            uint thing;
            uint padb[2];
            ushort part_a, part_b;
            uint thingb[6];
            uint one;
            char bfpad[0xba];
        } guest_elem[3];
    }
    else if (Strcmp(tag, "FIRE") == 0) /* FIRE [0.07] */
    {
        char empty[0x8de];
        uint count;
        uint thing;
    }
    else if (Strcmp(tag, "CSP.") == 0) /* CSP. [1.04] */
    {
        byte d; int b, c;

        struct { char unk[12]; } dont_know[3];
    }
    else if (Strcmp(tag, "CDP.") == 0) /* CDP. [1.05] */
    {
        uint seconds, available_addresses, one, zero;

        uint one; ubyte ip_addr_min[4];
        uint one; ubyte ip_addr_max[4];
        uint one; ubyte subnet_mask[4];
        uint zero;

        uint one; ubyte gateway_ip[4];
        uint one; ubyte gateway_ip_b[4];
        
        uint one, zero, sixtyfour, zero;
        uint one; ubyte gateway_ip_c[4];

        char tt[2];
        struct
        {
            ubyte optional_mac_addr[6] <format=hex>; /* swy: when config number is 4, maybe */
            time_t start, end;
            byte one; ubyte ip_addr[4];
            uint config_number; /* 0: free, 1 or 4 otherwise */

            /* swy: variable size, for some reason */
            byte six; ubyte mac_addr[six] <format=hex>;

            rgltag thing;
        } dhcp_entry[16] <optimize=false>;

        struct { char content[25]; } first[15]; //356 / 25];
        struct { char content[14]; } second[882 / 14];
        struct { char content[5]; } third[93 / 5];
    }
    else if (Strcmp(tag, "MLog") == 0) /* MLog [0.05] */
    {
        byte pad; rgltag superuser;
        byte pad; rgltag superuser_pwd;
        byte pad; rgltag mso;
        byte pad; rgltag mso_pwd;
        byte pad; char admin[16];
                  char passw[17];
        ubyte config[16];
    }
    else if (Strcmp(tag, "PRNT") == 0) /* PRNT [0.05] */
    {
        char broadcom_tag[16];
        ushort one_one; uint one_head, thirty;

        rgltag default_a;  uint one;
        rgltag anonymizer; uint one;
        rgltag anonymizer_dot_com;
        rgltag default_b;

        byte pad[3]; uint config[9];
    }
    else if (Strcmp(tag, "RG..") == 0) /* RG.. [0.30] */
    {
        byte h;
        char password[9];
        char vendor[256];  /* Netgear */
        short empty;
        uint blank;
        uint rg_settings_a; /* 0x9c -> 0x8c Respond to Ping on Internet Port on */
        uint rg_settings_b;
        uint rg_settings_c;
        uint rg_settings_d;
        uint rg_settings_e;
        char model_a[256]; /* CG3100 */
        char model_b[256]; /* empty */
        char model_c[256]; /* empty */
        byte unkbb[0x80];
        struct { byte array[9]; } aa[10];
        byte unkcc[0xd5];
        byte ss[0x54c];
        byte ntp_count;
        rgltag tags[ntp_count];
    }
    else if (Strcmp(tag, "Ntgr") == 0) /* Ntgr [0.14] */
    {
        byte pad[1800 - 1];
        uint unk, un;

        char superuser[16];
        char superuser_password[16];

        ushort tt[4];
        byte unkk[8];
        byte eightyone;

        char admin[16];
        char admin_password[16];

        char admin_b[16];
        char admin_password_b[16];

        byte more[17];

        rgltag admin_dynamic;
        rgltag passw_dynamic;
        byte padd[8];
        rgltag CM;
    }

    FSeek(saved_offset);
    FSkip(block_size);

} block_tag <optimize=false, read=Str("%s [%u.%02u]", this.tag, this.ver_a, this.ver_b), comment=comment_block_tag>;

string comment_block_tag( block_tag &r )
{
    if      (Strcmp(r.tag, "8021") == 0) /* 8021 [0.29] */ return "Wi-Fi (IEEE 802.11)";
    else if (Strcmp(r.tag, "WiGu") == 0) /* WiGu [0.10] */ return "Wi-Fi guest";
    else if (Strcmp(r.tag, "FIRE") == 0) /* FIRE [0.07] */ return "Firewall";
    else if (Strcmp(r.tag, "CSP.") == 0) /* CSP. [1.04] */ return "Static configuration protocol (SCP ??)";
    else if (Strcmp(r.tag, "CDP.") == 0) /* CDP. [1.05] */ return "Dynamic configuration protocol (DHCP - DCP?)";
    else if (Strcmp(r.tag, "MLog") == 0) /* MLog [0.05] */ return "Multiple systems operator (MSO) login credentials";
    else if (Strcmp(r.tag, "PRNT") == 0) /* PRNT [0.05] */ return "Print / Private network (??)";
    else if (Strcmp(r.tag, "RG..") == 0) /* RG.. [0.30] */ return "Residential gateway";
    else if (Strcmp(r.tag, "Ntgr") == 0) /* Ntgr [0.14] */ return "Netgear";
    return "";
}


/* swy: here's the start of the actual file */
ubyte salted_md5[16] <format=hex, comment="MD5 checksum of the config data block, using the provided size. Append the magic «2Pslc;u(egmd0-'x» salt value afterwards.">;

struct config_t
{
    char routerid_string[74];                     /* swy: 6u9e9ewf0jt9y85w690je4669jye4d-056t9p48jp4ee6u9ee659jy9e-54e4j6r0j069k-056 */
    byte ver_a, ver_b;                            /* swy: 0x0102 => 1.2, maybe */
    uint size <format=hex, comment="Total size">; /* swy: more often than not there's an extra/tailing 0x1 or 0x0 byte after the stated size; which breaks the bcm2cfg validation because that tool only chops off the first 16 bytes and appends the MD5 salt without reading the actual byte count here */

    while (FTell() < FileSize() - 1)
        block_tag block;

} config <open=true>;
