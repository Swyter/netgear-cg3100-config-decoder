//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

BigEndian();

typedef struct
{
    byte tag_len;
    if (tag_len)
        char s[tag_len];
} rgltag <read=read_rgltag, optimize=false>;

string read_rgltag(struct rgltag& _thing)
{
    if (_thing.tag_len <= 0)
        return "<empty>";
    else
        return _thing.s;
}

typedef struct
{
    ushort as <format=hex>;
    char tag[4];
    ubyte ver_a, ver_b;
    byte content[as - 6 - 2];
} block_tag <optimize=false, read=Str("%s [%u.%u]", this.tag, this.ver_a, this.ver_b)>;


ubyte salted_md5[16] <format=hex>;

struct config_t
{
    char routerid_string[74]; /* swy: 6u9e9ewf0jt9y85w690je4669jye4d-056t9p48jp4ee6u9ee659jy9e-54e4j6r0j069k-056 */
    byte ver_a, ver_b;
    uint size <format=hex>;   /* swy: more often than not there's an extra/tailing 0x1 or 0x0 byte after the stated size; which breaks the bcm2cfg validation because that tool only chops off the first 16 bytes and appends the MD5 salt without reading the actual byte count here */

    block_tag a[9];

    FSeek(0x2ab);
    ///rgltag aa[20];

    byte prev;
    byte pad[size-(startof(prev)+1 - startof(config))];
} config <open=true>;

