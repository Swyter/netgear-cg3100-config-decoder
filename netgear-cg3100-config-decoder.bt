//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: Netgear GC3100 *decoded* config backup
//   Authors: Swyter
//   Version: 2022.02.05
//   Purpose: Open descrambled GatewaySettings.bin files.
//  Category: Network
//  ID Bytes: [+16] 36 75 39 65 [+46] 01 02
// File Mask: GatewaySettings*.bin*
//------------------------------------------------

BigEndian();

typedef struct
{
    byte tag_len;
    if (tag_len)
        char s[tag_len];
} rgltag <read=read_rgltag, optimize=false>;

string read_rgltag(struct rgltag& _thing)
{
    if (_thing.tag_len <= 0) return "<empty>"; else return _thing.s;
}

typedef struct
{
    local int saved_offset = FTell();

    ushort block_size <format=hex>;
    char tag[4]; ubyte ver_a, ver_b;

    if      (Strcmp(tag, "8021") == 0) /* 8021 [0.29] */
    {
        char wifi_ssid[33];
    }
    else if (Strcmp(tag, "WiGu") == 0) /* WiGu [0.10] */
    {
        byte zero;
        struct elem
        {
            ushort num;
            char wifi_ssid[33];
            ushort numb;
            char buf[74];
            char pad[40];
            uint thing;
            uint padb;
            uint thingb[7];
            uint one;
            char bfpad[0xbf];
        } guest_elem[3];
    }
    else if (Strcmp(tag, "FIRE") == 0) /* FIRE [0.07] */
    {
        int c;
    }
    else if (Strcmp(tag, "CSP.") == 0) /* CSP. [1.04] */
    {
        int d;
    }
    else if (Strcmp(tag, "CDP.") == 0) /* CDP. [1.05] */
    {
        int e;
    }
    else if (Strcmp(tag, "MLog") == 0) /* MLog [0.05] */
    {
        rgltag tags[9];
        char admin[16];
        char passw[17];
    }
    else if (Strcmp(tag, "PRNT") == 0) /* PRNT [0.05] */
    {
        rgltag tags[3];
    }
    else if (Strcmp(tag, "RG..") == 0) /* RG.. [0.30] */
    {
        byte h;
        char password[9];
        char vendor[256];  /* Netgear */
        ubyte unk_crap[0x1a];
        char model_a[256]; /* CG3100 */
        char model_b[256]; /* empty */
        char model_c[256]; /* empty */
        byte unkbb[0x80];
        struct { byte array[9]; } aa[10];
        byte unkcc[0xd5];
        byte ss[0x54c];
        byte ntp_count;
        rgltag tags[ntp_count];
    }
    else if (Strcmp(tag, "Ntgr") == 0) /* Ntgr [0.14] */
    {
        byte pad[1800 - 1];
        uint unk, un;

        char superuser[16];
        char superuser_password[16];

        ushort tt[4];
        byte unkk[8];
        byte eightyone;

        char admin[16];
        char admin_password[16];

        char admin_b[16];
        char admin_password_b[16];

        byte more[17];

        rgltag admin_dynamic;
        rgltag passw_dynamic;
        byte padd[8];
        rgltag CM;
    }

    FSeek(saved_offset);
    FSkip(block_size);

} block_tag <optimize=false, read=Str("%s [%u.%02u]", this.tag, this.ver_a, this.ver_b), comment=comment_block_tag>;

string comment_block_tag( block_tag &r )
{
    if      (Strcmp(r.tag, "8021") == 0) /* 8021 [0.29] */ return "Wi-Fi (IEEE 802.11)";
    else if (Strcmp(r.tag, "WiGu") == 0) /* WiGu [0.10] */ return "Wi-Fi guest";
    else if (Strcmp(r.tag, "FIRE") == 0) /* FIRE [0.07] */ return "Firewall";
    else if (Strcmp(r.tag, "CSP.") == 0) /* CSP. [1.04] */ return "???";
    else if (Strcmp(r.tag, "CDP.") == 0) /* CDP. [1.05] */ return "???";
    else if (Strcmp(r.tag, "MLog") == 0) /* MLog [0.05] */ return "Multiple systems operator (MSO) login";
    else if (Strcmp(r.tag, "PRNT") == 0) /* PRNT [0.05] */ return "Print";
    else if (Strcmp(r.tag, "RG..") == 0) /* RG.. [0.30] */ return "Residential gateway";
    else if (Strcmp(r.tag, "Ntgr") == 0) /* Ntgr [0.14] */ return "Netgear";
    return "";
}


/* swy: here's the start of the actual file */
ubyte salted_md5[16] <format=hex, comment="MD5 checksum of the config data block, using the provided size. Append the magic «2Pslc;u(egmd0-'x» salt value afterwards.">;

struct config_t
{
    char routerid_string[74];                     /* swy: 6u9e9ewf0jt9y85w690je4669jye4d-056t9p48jp4ee6u9ee659jy9e-54e4j6r0j069k-056 */
    byte ver_a, ver_b;                            /* swy: 0x0102 => 1.2, maybe */
    uint size <format=hex, comment="Total size">; /* swy: more often than not there's an extra/tailing 0x1 or 0x0 byte after the stated size; which breaks the bcm2cfg validation because that tool only chops off the first 16 bytes and appends the MD5 salt without reading the actual byte count here */

    while (FTell() < FileSize() - 1)
        block_tag block;

} config <open=true>;
